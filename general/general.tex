\documentclass{article}
\usepackage{geometry}
\usepackage{graphicx} % Required for inserting images
\usepackage{amsmath, amsthm, amssymb}
\usepackage{mathtools}
\DeclarePairedDelimiter\ceil{\lceil}{\rceil}
\DeclarePairedDelimiter\floor{\lfloor}{\rfloor}
\usepackage{parskip}
\newgeometry{vmargin={15mm}, hmargin={24mm,34mm}}
\theoremstyle{definition} 

\newtheorem{definition}{Definition}
\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{corollary}{Corollary}[theorem]
\newtheorem{proposition}[theorem]{Proposition}
\newcommand{\N}{\mathbb{N}}
\newcommand{\Z}{\mathbb{Z}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\Q}{\mathbb{Q}}
\newcommand{\xtoc}{\lvert x \rvert ^{c}}
\newcommand{\bitstring}[1]{\{0,1\}^{#1}}
\newcommand{\Gen}{\textbf{Gen}}
\newcommand{\Sample}{\textbf{Sample}}
\newcommand{\Eval}{\textbf{Eval}}
\newcommand{\Invert}{\textbf{Invert}}

\DeclareMathOperator*{\E}{\mathbb{E}}

\title{Cryptography}
\date{March 2024}
\author{Boran Erol}

\begin{document}

\maketitle

\section{One-Way Functions}

The existence of OWFs is equivalent to the existence of all (non-trivial) private-key
cryptography.

Notice that the probability of inversion is taken over an experiment in which $y$ is
generated by choosing a uniform element $x$ in the domain rather than choosing $y$
uniformly in the range of $f$. It is also taken over the random coins of the
adversary.

The definition by Lindell and Katz in Intro to Modern Cryptography is great.

\begin{definition}
    A function $f: \{0,1\} \xrightarrow{} \{0,1\}$ is \textbf{one-way} if the following two conditions hold

\end{definition}

It is unknown whether we can construct CRHFs from OWFs.

\begin{definition}
    A function $f$ that is length preserving and a one-way function is said to be
    a \textbf{one-way permutation}.
\end{definition}

Notice that the existence of OWFs is much stronger than P $\neq$ NP. We're not assuming
worst-case hardness, we're assuming average-case hardness.



\subsection{Candidate One-Way Functions}

\begin{enumerate}
    \item Integer Factorization
    \item Subset Sum
    \item The Hardness of Discrete Log (OWP)
\end{enumerate}

\subsection{Hard-Core Predicates}

Let $f$ be a one-way function. Notice that the function $g(x_{1},x_{2}) := (f(x_{1}),x_{2})$
is also a OWF but leaks half of its input.

\begin{definition}
    A function $hc: \bitstring{*} \xrightarrow{} \{0,1\}$ is a \textbf{hard-core predicate of a function $f$}
    if $hc$ can be computed in polynomial time and for every probabilistic polynomial-time algorithm $A$

    \[ \Pr_{x \xleftarrow{\$} \bitstring{n}}[A(1^{n},f(x)) = hc(x)] \leq \frac{1}{2} + negl(n)\]
\end{definition}

Notice that the above definition doesn't require $f$ to be one-way. Moreover, it's easy to construct
functions that are trivially hard-core predicates (see Katz Lindell 7.1), but these are useless.

After seeing this definition, one natural question to ask is the following:
Is there a function $hc$ that is a hard-core predicate for all one-way functions $f$.
It turns out that the answer is negative.

Let's now examine a plausible looking $hc$ and construct a OWF $f$ to break it.
Let $hc$ be defined by XORing the bits of $x$.

\begin{lemma}
    For any fixed $hc$, there's a one-way function $f$ such that 
    $hc$ is not a hard-core predicate of $f$
\end{lemma}
\begin{proof}
    
\end{proof}

Goldreich and Levin Theorem shows how to construct a hard-core predicate
for every OWF.

\subsection{PRGs from OWPs and OWFs}

\begin{definition}
    A deterministic polynomial time algorithm $G$ is a PRG if there's 
    a stretch function $l: \N \xrightarrow{} \N$ (satisfying $\forall k: l(k) > k$)
    such that for all PPT's D, for all positive polynomials $p$, and for all
    sufficiently large $k$ we have that 

    \[ \lvert \Pr[D(G(U_{k})) = 1] - \Pr[D(U_{l(k)}) = 1] \rvert \leq \frac{1}{p(k)}\]

    where the probability is taken over $U_{k}$ and the coin tosses of $D$.
\end{definition}

PRGs can be used to reduce the randomness complexity of randomized algorithms
without making a noticeable difference in their output.

Statistically close distributions are trivially computationally indistinguishable.

You can upgrade single-sample indistinguishability to multi(polynomial)-sample indistinguishability
by using a hybrid argument where the neighboring distributions differ by a single sample.



We'll now show how to get a PRG from an OWP. It is well-known that an OWF suffices.

\begin{theorem}
    Let $f$ be an OWP and $hc$ be a hard-core predicate of $f$. Then, $G(s) = f(s) || hc(s)$
    is a PRG with expansion factor $l(n) = n + 1$.
\end{theorem}
\begin{proof}
    
\end{proof}

Let's now try to build PRGs with arbitrary expansion factors.

\begin{theorem}
    If there exists a PRG with expansion factor $l(n) = n + 1$, then for any polynomial $f$
    there exists a PRG with expansion factor $f(n)$.
\end{theorem}

\subsection{PRFs from PRGs}

\begin{theorem}
    If there exists a PRG with expansion factor $l(n) = 2n$, then there exists a PRF.
\end{theorem}

\begin{theorem}
    If there exists a PRF, then there exists a strong PRF.
\end{theorem}

\subsection{OWF Exercises, Lindell and Katz}

\subsubsection{Exercise 1}

\begin{lemma}
    If there exists a OWF, there exists a OWF $f$ such that
    $\forall n \in \N: f(0^{n}) = 0^{n}$.
\end{lemma}
\begin{proof}
    Intuitively, this is because in the inversion experiment, we sample the all zeros string
    with negligible probability.
\end{proof}

\subsubsection{Exercise 3}

\begin{lemma}
    The existence of OWFs imply the existence of OWPs.
\end{lemma}
\begin{proof}
    
\end{proof}

\subsubsection{Exercise 4}

\begin{lemma}
    Let $(Gen,H)$ be a collision-resistant hash function, where $H$ maps string of length $2n$
    to strings of length $n$. Then, the function family $(Gen, Samp, H)$ is one-way, where $Samp$
    is the trivial algorithm that samples a uniform string of length $2n$.

    In particular, the existence of CRHFs imply the existence of OWFs.
\end{lemma}
\begin{proof}
    
\end{proof}

\newpage

\subsubsection{Exercise 5}

Let $F$ be a length-preserving pseudorandom permutation.

\subsubsection{Exercise 15}

Just put append $n$ keys together and put the functions
one after each other.

\subsubsection{Exercise 19}

Just feed the challenge string to the adversary $A$ and act accordingly.
There'll be a noticeable difference.

\newpage

\section{Trapdoor OWPs}

The following is based on Lecture 1, Katz UMD Cryptography course. Check the
lecture notes there for an in-depth discussion.

Let's first not worry about security at all and give a syntactic definition
of trapdoor permutation families.

A \textbf{trapdoor permutation family} is a tuple of algortihms
$(\Gen, \Sample, \Eval, \Invert)$ such that 

\begin{enumerate}
    \item $\Gen(1^{k}) = (i, td)$
    \item $\Sample(1^{k}, i) = x$, where $x$
    is uniformly random in $D_{i}$.
    
    Intuitively, $\Sample$ let's us sample uniformly from $D_{i}$.
    \item $\Eval(1^{k},i,x) = y$
    
    For all $i$ output by $\Gen$, $Eval(1^{k},i, \cdot)$ is a permutation.
    \item $\Invert(1^{k}, td, y) = x$
\end{enumerate}

We require $\Eval$ and $\Invert$ to be deterministic.
Notice that we're feeding $i$ to $\Invert$ through $y$ implicitly.

\begin{definition}[Correctness]
    For all $i$ output by $\Gen$ and $x$ output by $\Sample$, we have that

    \[ \Invert(1^{k},td, \Eval(1^{k}, i, x)) = x\]
\end{definition}

Notice that $f^{-1}$ exists even without the trapdoor.

$\Invert$ just makes $f^{-1}$ efficient using $td$. Intuitively,
we'll require that computing $f^{-1}$ is difficult without $td$.

\begin{definition}
    A trapdoor permutation family $(\Gen, \Sample, \Eval, \Invert)$
    is \textbf{one-way} if for any PPT $A$:

    \[ \]
\end{definition}

\subsection{RSA as a Trapdoor OWP}

$\Gen(1^{k})$

Sample two $k$ bit primes $p$ and $q$. Set $N = pq$.

Sample $e$ from $Z^{*}_{N}$ and set $d$ to be the inverse
of $d$, i.e. $ed = 1$.

Let $i = (N, e)$ and $td = (N,d)$.

Set $D_{i} = Z^{*}_{N}$.

$\Sample(1^{k}, i)$

Sample from $Z^{*}_{N}$.

$\Eval(1^{k},(N,e), x) = x^{e} \pmod{N}$

$\Invert(1^{k},(N,d), y) = y^{d} \pmod{N}$



\newpage

\section{Claw-Free Permutations}

\begin{definition}
    A group of three numbers $(x,y,z)$ is a \textbf{claw} for permutations $f_{0}$ and $f_{1}$ if

    \[ f_{0}(x) = f_{1}(y) = z \]
\end{definition}

A pair of permutations is said to be \textbf{claw-free} if there's no efficient algorithm for computing a claw.

Constructing perfectly hiding commitment schemes from claw-free permutations is easy. Here's how to do it.

The sender samples a uniformly random bit and sends $f_{b}(x)$ to the receiver. The receiver has no clue
which permutation the sender user and the sender can't cheat since the permutations are claw-free.

Claw-free permutations are similar to CRHFs in the following sense.

\begin{lemma}
    Claw-free permutations imply CRHFs.
\end{lemma}
\begin{proof}
    
\end{proof}

\newpage

\section{Commitment Schemes}

There are also instance-dependent commitment schemes. For example, a commitment scheme might be hiding
for $x \in L$ and binding for $x \notin L$. Notice that this would be very useful in ZK proofs.

\subsection{Pedersen Commitments}

\subsection{Commitment Schemes from CRHFs}

\subsection{Commitment Schemes in ROM}

\subsection{Commitment Schemes from OWFs}

\subsection{Coin Flipping from Bit Commitment Protocols}

Here's how to get a secure coin flipping protocol from a bit commitment protocol.

Alice samples a random bit $b_{0}$ and sends a commitment of $b_{0}$
to Bob. Bob randomly samples $b_{1}$ and sends it to Alice. Alice
then decommits to $b_{0}$. Both parties calculate $b_{0} \oplus b_{1}$.

The fact that Alice can't cheat comes from the binding property
of the commitment scheme. The fact that Bob can't cheat comes from the
hiding property of the commitment scheme.

\newpage

\section{Collision-Resistant Hash Functions}

See Chapter 5.6 in Lindell and Katz for some applications of CRHFs.

\begin{lemma}
    Let $(Gen, H)$ be a CRHF. Define $(Gen, \hat{H})$ by $\hat{H}^{s}(x) = H^{s}(H^{s}(x))$.
    $(Gen, \hat{H})$ is also a CRHF.
\end{lemma}
\begin{proof}
    By contradiction, assume there's some PPT adversary $A$ that finds $x,x^{\prime}$ such that
    $\hat{H}^{s}(x) = \hat{H}^{s}(x^{\prime})$ with noticeable probability. Then, either

    \[ H^{s}(x) = H^{s}(x^{\prime})\]

    \[ \hat{H}^{s}(x) = \hat{H}^{s}(x^{\prime})\]

    In each case, we break the collision resistance of $H$. We thus conclude the proof.

\end{proof}

\newpage

\section{PKE}

\subsection{CPA Security}

\begin{definition}
    A public key encryption scheme is a triple of algorithms $(Gen, Enc, Dec)$
    such that 

    \begin{enumerate}
        \item $Gen(1^{k}, r) = (pk, sk)$
        \item $Enc(m, pk) = c$
        \item $Dec(c, sk) = m$
    \end{enumerate}
\end{definition}

\begin{definition}[Correctness]
    
\end{definition}

\begin{definition}[Semantic Security]
    
\end{definition}

\begin{definition}[IND-CPA Security]
    
\end{definition}

The challenger runs $\Gen(1^{k}, r)$ and sends $pk$ to the adversary.

Then, the adversary picks two messages $m_{0},m_{1}$ and sends them to the challenger.

The challenger flips a coin $b \xleftarrow{\$} \{0,1\}$ and sends $Enc(m_{b}, sk)$.

The adversary wins if it can predict $b$.

Notice that the adversary can predict with probability $\frac{1}{2}$ trivially.

Also notice that our encryption algorithm needs to be randomized in order to satisfy IND-CPA security.
Otherwise, tha adversary can encrypt the challenge strings on its own and beat the challenge trivially.

Also, by a hybrid argument, PKE schemes that are single-message secure are secure for polynomially
many messages.

\newpage

\subsection{DDH and El-Gamal PKE}

DDH was introduced in 1976, for which Diffie and Hellman got the Turing Award.
El-Gamal PKE is almost identical to the Diffie-Hellman Key Exchange, but it took
9 years to discover. This is another example of a simple brilliant idea hiding under our nose.

Here's the decisional Diffie-Hellman assumption:

\begin{definition}
    Let $q$ be a prime and consider a group $G$ with $\lvert G \rvert = q$.
    The following two distributions are computationally indistinguishable:

    \[ (x,y \xleftarrow{\$} G: g^{x},g^{y}, g^{xy}) \approx_{c}(x,y,r \xleftarrow{\$} G: g^{x},g^{y}, g^{r})\]
\end{definition}

Here's how to construct a key exchange from the DDH assumption:


Here's how to construct El-Gamal PKE from the DDH assumption:



\newpage

\subsection{PKE from Trapdoor OWPs}

\subsection{CCA-1 Security (Lunchtime Attacks)}

Suppose an employee decrypts some important information about a company
during lunch. Afterwards, the employee is fired. Is the encryption scheme
still secure now that the adversary has access to plaintexts and ciphertexts
of its choice?

Simply put, we'd like our PKE scheme to be secure \textbf{even if}
the adversary gets access to the decryptions of polynomially many ciphertexts 
before the challenge.

Proving the security of CCA-1 secure schemes are often as hard as constructing
the schemes. The reductions are pretty hard.

\subsubsection{Naor-Yung Construction of CCA1 Secure PKE Schemes using Adaptively-Secure NIZKs}

This was the first ever CCA-1 secure PKE scheme.

\textbf{Resources}
\begin{enumerate}
    \item Jonathan Katz UMD Graduate Course Lecture 6,7
    \item The original paper from 1990
\end{enumerate}

For $\Gen$, run two key generation algorithms from a CPA-secure PKE scheme.
For encryption, encrypt the message using both schemes using different randomness.
Then, give a NIZK proof that you encrypted the same message.


\subsection{CCA-2 Security}

In CCA-2 security, the adversary can get decryptions of ciphertext even after
the challenge sends the challenge ciphertext $c$. Naturally, we don't allow the adversary
to ask for decryptions of the two ciphertexts it received as a challenge.

Notice that CCA-2 security doesn't hold for homomorphic encryption schemes. The adversary
can just decrypt twice the encrypted message and ask for the challenger to decrypt.

CCA-2 security is equivalent to non-malleability.

In 1998, NIST published a CCA-1 secure encryption scheme as the encryption standard and  Daniel Bleichenbacher 
embarassed them. He has Asperger's and got extremely mad at Rafi because Rafi supported the Iraq war.

Cramer-Shoup encryption based on El-Gamal encryption is the classic CCA-2 secure encryption
scheme.

\subsubsection{Dwork, Dolev and Naor 1991 CCA-2 Secure Construction}

Let the length of public key of the signature scheme be $l$.

Run $2l$ semantically secure PKE KeyGen algorithms.
Let $r$ be a random string.

Let $h$ be a CRH.




\newpage

\section{Digital Signature Schemes}

\subsection{Resources}

\begin{enumerate}
    \item Chapter 12 in Katz and Lindell
\end{enumerate}

\subsection{Introduction and Motivation}

Digital signature schemes are \textbf{publicly verifiable} and \textbf{transferable}.

They also have the property of \textbf{non-repudiation}.

Digital signature schemes are NOT inverse PKE schemes.



\newpage

\section{Common Reference String Model}

Captures the assumption of a trusted setup where all 
parties have access to the same string crs 
(common reference string) taken from some distribution D.

\newpage

\section{Private Information Retrieval}

Private information retrieval is a relaxation of OT where a user queries data from a server which has a database, and the server doesn't gain 
information about which data the user received. However, we remove the requirement that the user doesn't learn anything about the data it doesn't retrieve.
PIR was introduced by Chor, Goldreich, Kushilevitz and Sudan in 1995.

Let's consider a game with a user $U$ and a database $DB$.
WLOG, assume the database is some string $x \in \bitstring{n}$.

Notice that we can trivially achieve PIR by downloading the entire database.
Therefore, the challenge in PIR is to reduce the communication complexity as much as possible. It's not a problem
of feasibility.

Notice that even without privacy, the communication complexity is $O(\log n)$ where the user sends $i$ in the open and the server sends $x_{i}$.

\begin{theorem}[Cnor, Goldreich, Kushilevitz, Sudan 1995]
    Information-theoretic PIR with a single server with communication complexity less than $n$ bits is impossible.
\end{theorem}

\begin{theorem}[Kushilevitz, Ostrovksy 1997]
    It is possible for computational security.
\end{theorem}


\subsection{Multi-server PIR}

Here's a basic scheme for two servers. We assume that the two servers don't collude.
View the DB $x \in \bitstring{n}$ as an $\sqrt(n) \times \sqrt(n)$ matrix X.
The client wants to read $(i,j) \in [\sqrt(n) \times \sqrt(n)]$.

Rest in Notability.

\subsection{Single Server PIR}

The idea is to encrypt the query instead of secret sharing it.

It uses linearly homomorphic encryption.

The security follows from the security of LHE.

The communication is now $2\sqrt(n)$ ciphertexts.

It is possible to get $polylog(n)$ communication.

\subsection{PIR in Practice}

To support longer DB records, we can just use PIR for 1-bit records $l$ times. Therefore,
it's as if we have $l$ individual databases.



\newpage

\end{document}


